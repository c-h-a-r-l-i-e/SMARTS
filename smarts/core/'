# Copyright (C) 2020. Huawei Technologies Co., Ltd. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
import math
import numpy as np

from smarts.core.coordinates import Heading, Pose
from smarts.core.chassis import BoxChassis
from smarts.core.controllers.pure_controller import (
    PureController,
    PureLaneFollowingController,
)


class CarsimCar:
    """
    An object which carsim.logic can take in order to calcualte safe actions
    """
    def __init__(self, vehicle_state, ref_lane, road_network):
        """
        Export a car to be used in carsim code, translating it relative to the provided lane.

        params
        ---------
        vehicle_state: VehicleState
            The vehicle we want to translate
        ref_lane : sumo.Lane
            The lane we want to translate relative to
        road_network : SumoRoadNetwork
            The road network we're working in
        """
        position = vehicle_state.pose.position[:2]
        try:
            u, v = world_to_lane_coord(ref_lane, position)

        except ValueError:
            # The vehicle does not lie on the lane
            pass



        self.v = vehicle_state.speed
        self.x = vehicle_state.pose.position[0]
        self.y = vehicle_state.pose.position[1]
        self.theta = car.pose.heading
        self.length = car.length
        self.width = car.width



class SafetyPureController:
    @classmethod
    def perform_action(cls, sim, sensor_state, vehicle, action, dt): # TODO: change the call for this to match
        """
        Check if an action is safe, and if not modify it to be as safe as possible, then
        execute using pure physics (no pybullet).
        """
        assert isinstance(vehicle.chassis, BoxChassis)
        # Process the action inputs
        throttle, brake, steering_angle = action
        
        throttle = np.clip(throttle, 0, 1)
        brake = np.clip(brake, 0, 1)
        steering_angle = np.clip(steering_angle, -1, 1)

        a = throttle * vehicle.max_accel - brake * vehicle.max_brake
        delta = steering_angle * np.pi/4

        road_network = sensor_state.mission_planner._road_network

        # Calculate safe actions
        # 1. Get all surrounding vehicles
        vehicles = sim.neighborhood_vehicles_around_vehicle(vehicle = vehicle, radius = np.inf) 

        # 2. Calculate ego vehicle surrounding lanes list
        current_lane = road_network.nearest_lane(vehicle.pose.position[:2])
        surrounding_lanes = current_lane.getEdge().getLanes()
        surrounding_lanes_sets = [{*lane.getIncoming(), lane} for lane in surrounding_lanes] # extend with road predecessors
        all_surrounding_lanes_set = set.union(*surrounding_lanes_sets)

        # 3. For each vehicle, work out which lanes they're in
        vehicle_lanes = {v.vehicle_id: SafetyPureController.get_vehicle_lanes(v, road_network) for v in vehicles}
        # filter out vehicles not in the surrounding lanes
        vehicles = [v for v in vehicles if not vehicle_lanes[v.vehicle_id].isdisjoint(all_surrounding_lanes_set)]


        # 4. Order vehicles based on distance along ego vehicle's road
        lane_local_offsets = {v.vehicle_id: road_network.offset_into_lane(current_lane, v.pose.position[:2]) for v in vehicles}
        vehicles.sort(key = lambda v : lane_local_offsets[v.vehicle_id])

        # 5. Generate the surroundings
        ego_pos = road_network.offset_into_lane(current_lane, vehicle.pose.position[:2])
        surroundings = [[None, None] for i in range(len(surrounding_lanes))]
        for v in vehicles:
            for lane_num, surrounding_lane_set in enumerate(surrounding_lanes_sets):
                if not vehicle_lanes[v.vehicle_id].isdisjoint(surrounding_lane_set):
                    if lane_local_offsets[v.vehicle_id] < ego_pos:
                        # Car is in surrounding lane, and behind ego vehicle
                        surroundings[lane_num][0] = v
                    else:
                        # Car is in surrounding lane, and ahead of ego vehicle
                        if surroundings[lane_num][1] is None:
                            surroundings[lane_num][1] = v


        

        if vehicle.id[6] == "1":
            print("info from vehicle id: {}".format(vehicle.id))
            print("surroundings :")
            for surrounding in surroundings:
                r = surrounding[0].vehicle_id if surrounding[0] is not None else None
                f = surrounding[1].vehicle_id if surrounding[1] is not None else None
                print("{}|{}".format(r, f))

#            print("current_lane id : {}".format(current_lane.getID()))
#            print("surrounding lanes : {}".format([[lane.getID() for lane in lane_list] for lane_list in surrounding_lanes_sets]))
#            #print("vehicles : {}".format(vehicles))
#            print("")
#            for v in vehicles:
#                #print("vehicle {} in lanes : {}".format(v.vehicle_id, [lane.getID() for lane in vehicle_lanes[v.vehicle_id]]))
#                print("vehicle {} in local position : {}".format(v.vehicle_id, lane_local_offsets[v.vehicle_id]))

        # 3. Pass information to our safety calculator to work out a safe action, hopefully
        #    close to the original action intention.

#        deltas = carsim.logic.calculate_safe_deltas(...)
#
#        # Check if deltas empty
#        if deltas empty:
#            a = - vehicle.max_brake
#            deltas = carsim.logic.calcaulte_safe_deltas(...)
#
#            if deltas empty:
#                # Set delta to follow lane somehow
#
#
#        # Find closest delta

        action = (throttle, brake, steering_angle)
        PureController.perform_action(vehicle, action, dt)



    @staticmethod
    def get_vehicle_lanes(vehicle, road_network):
        x, y = vehicle.pose.position[:2]
        heading = vehicle.pose.heading + np.pi/2
        l = vehicle.dimensions.length
        w = vehicle.dimensions.width

        # Offsets are all the corners of the vehicle 
        # If some vehicles are not registering in a lane, may be worth adding more offsets
        offsets = np.array(((l/2, w/2), (l/2, -w/2), (-l/2, w/2), (-l/2, -w/2)))
        c, s = np.cos(heading), np.sin(heading)
        rot = np.array(((c, -s), (s, c)))
        offsets = np.array([rot.dot(offset) for offset in offsets])
        corners = np.array((x,y)) + offsets

        lanes = set()
        for corner in corners:
            lane = road_network.nearest_lane(corner)
            if lane is not None:
                lanes.add(lane)

        return lanes
            








class SafetyPureLaneFollowingController:
    @classmethod
    def perform_lane_following(
        cls,
        sim,
        agent_id,
        vehicle,
        controller_state,
        sensor_state,
        dt,
        target_speed=12.5,
        lane_change=0,
    ):
        # For now this method simply passes the lane following action the safety controller, which should ensure that
        # each action is individually safe.
        lane_change = 0
        action = PureLaneFollowingController.get_action(sim, vehicle, sensor_state, dt, target_speed, lane_change)
        SafetyPureController.perform_action(sim, sensor_state, vehicle, action, dt)


